---
tags:
  - Android
  - 1402_2
enableOverview: "true"
css:
  - css/shabnam.css
theme: black
---

<!-- slide dir="rtl" -->

![[University-of-Isfahan.png|200]]

## برنامه نویسی دستگاه‌های سیار
#### درسنامه 14: معماری اندروید

- ترم بهار 1402-1403 دانشگاه اصفهان 
- نوید شیرمحمدی
---
<!-- slide bg="#2d4726"  dir="rtl" -->
- کانال: t.me/android_ui02

---
<!-- slide bg="#d24726" dir="rtl" -->
## در این درسنامه
- آشنایی با معماری اندروید
- اجزای برنامه‌ی اندروید
- مدل امنیتی اندروید

---
<!-- slide dir="rtl"-->
### معماری اندروید

![[Pasted image 20240515220638.png]]

---
### Linux Kernel
- اندروید روی هسته‌ی لینوکس ساخته شده
- **درایورهایی** برای سخت‌افزار، شبکه، دسترسی به **سیستم‌فایل** و مدیریت **فرآیند** را فراهم می‌کند

---
<!-- slide dir="rtl"-->
### Native User Space
- لایه‌ی بالای هسته
- شامل:
	- باینری Init (اولین برنامه‌ای که اجرا میشه)
	- کتابخانه‌ها و daemon های محلی
	- hardware abstraction layer

---
<!-- slide dir="rtl"-->
### ماشین مجازی Dalvik
- پیاده‌سازی خاص JVM برای اندروید 
	- نمیتونه مستقیم فایل class اجرا کنه
	- بجاش Dalvik Executable (DEX) اجرا میکنه
- دستورالعمل‌های DEX با JVM متفاوته (کوتاهتره)

![[Pasted image 20240515221952.png]]

---
<!-- slide dir="rtl"-->
### Java Runtime Libraries
- پیاده‌سازی کتابخانه‌های جاوا برای اندروید
	- به کد‌های محلی اندروید وابستگی داره
	- پروژه Apache Harmony
	- با جاوا نوشته شدن

---
<!-- slide dir="rtl"-->
### System Services
- ویژگی‌های بنیادی اندروید از جمله پشتیبانی از نمایشگر و صفحه لمسی، تلفن و اتصال شبکه را پیاده‌سازی می‌کنند.
- با معرفی service discovery, meditation و IPC لینوکس را به یه سیستم‌عامل شی‌گرا تبدیل می‌کنند.

---
<!-- slide dir="rtl"-->
### Inter-Process Communication (IPC)
- فرآیندها در اندروید دارای فضای آدرس جداگانه‌ای هستند و یک فرآیند نمی‌تواند به طور مستقیم به حافظه فرآیند دیگر دسترسی داشته باشد.
- با IPC مکانیزمی فراهم میشه که به فرآیندهای دیگر اجازه میده تا خدمات برنامه ما را کشف کنن و باهاشون تعامل داشته باشن
- خیلی قابل اعتماد نبود و Binder جاش اومد!
---
<!-- slide dir="rtl"-->
### Binder
- همه‌ی IPC ها ازش رد میشن و امنیتشون را کنترل میکنه
- خودش جزئی از هسته است

![[Pasted image 20240515223525.png]]

---
<!-- slide dir="rtl"-->
### کتابخانه‌های فریم‌ورک اندروید
- کلاس‌های پایه برای 
	- Activity، Service و ContentProvider
	- ویجت‌های رابط کاربری گرافیکی
	- کلاس‌های دسترسی به فایل و پایگاه داده
	- کلاس‌های کار با سخت‌افزار دستگاه
	- ...
- بعضا مستقیما قابل دسترس نیستند (مجوز یا manager لازمه) 

---
### برنامه‌ها
- برنامه‌های سیستمی
- برنامه‌های نصب شده توسط کاربر

---
<!-- slide dir="rtl"-->
### برنامه‌های سیستمی
- در ایمیج سیستم هیتند و قابل تغییر نیستند
- امتیازات بالا دارند (دسترسی به بخش‌های مختلف سیستم و ...)
- در مسیر system قرار دارند
- میشه به برنامه‌ای که سیستمی نیست دسترسی معادل داد (مثل launcher)

---
<!-- slide dir="rtl"-->
### برنامه‌های نصب شده توسط کاربر
- معمولا در مسیر data قرار دارند
- نمی تواند بر سایر برنامه ها تأثیر بگذارد یا به داده های آنها دسترسی پیدا کنن
- فقط می‌توانند به منابعی دسترسی داشته باشند که به طور صریح برای استفاده از آنها مجوز دریافت کردن

---
<!-- slide dir="rtl"  bg="#d24726"-->
## اجزای برنامه‌ی اندروید

---
<!-- slide dir="rtl" -->
تعریف کنین 😧
- Activity
- Service
- Content Provider
- Broadcast Receiver

---
<!-- slide dir="rtl"  bg="#d24726"-->
## مدل امنیتی اندروید

---
<!-- slide dir="rtl" -->
- Application Sandboxing
- Permissions
- IPC
- Code Signing and Platform Keys
- Multi-User Support
- SELinux

---
<!-- slide dir="rtl" -->
### Application Sandboxing
برای جداسازی اجرای برنامه ها و جلوگیری از گسترش باگ‌ها و آسیب‌پذیری های نرم افزاری به سایر بخش‌های سیستم عامل استفاده می شه.
- هر برنامه در زمان نصب یک شناسه دریافت می‌کنه
- هر برنامه یک دایرکتوری داده اختصاصی دارد که تنها خود برنامه اجازه خواندن و نوشتن به آن را دارد

![[Pasted image 20240517112608.png]]

---
<!-- slide dir="rtl" -->
### Permissions
- دسترسی سندباکس خیلی محدوده
- کنترل دسترسی به سخت افزار، اتصال به اینترنت، داده ها یا سرویس های سیستم عامل را با درخواست مجوز میشه انجام داد.
- در فایل AndroidManifest.xml
- برخی از مجوزها تنها به برنامه هایی که بخشی از سیستم عامل اندروید هستند قابل اعطا می باشند، زیرا آنها یا پیش نصب شده اند یا با همان کلید سیستم عامل امضا شده اند.

---

- **READ_PHONE_STATE:** This permission allows an application to read the phone's state, such as the phone number, IMEI number, and SIM serial number.
- **READ/WRITE_CONTACTS:** This permission allows an application to read the user's contact list.

---
<!-- slide dir="rtl" -->
### IPC
- با استفاده از ترکیبی از یک درایور کرنل و کتابخانه های فضای کاربری انجام میشه.
- درایور کرنل Binder تضمین می کند که UID و PID فراخواننده ها قابل جعل نیستند.
- بسیاری از سرویس های سیستمی برای کنترل پویای دسترسی به API های حساس که از طریق IPC در معرض دید قرار می گیرند.
- در فایل AndroidManifest.xml
- اگر مجوز مورد نیاز را نداشته نباشد، سیستم یک SecurityException صادر می کند.

---
<!-- slide dir="rtl" -->
### Code Signing and Platform Keys
- تمامی برنامه های اندروید، از جمله برنامه های سیستمی، باید توسط توسعه دهنده خود امضا شوند.
- امضای APK برای اطمینان از این که به روزرسانی های یک برنامه از توسعه دهنده مشابهی باشند
- برنامه های سیستمی با تعدادی از کلیدهای پلتفرم امضا می شوند که تولید کننده گوشی، Google و ... موقع نصب سیستم به دستگاه کلید عمومی نظیرشون را میدن

---
<!-- slide dir="rtl" -->
### Multi-User Support
- پشتیبانی از چندین کاربر فیزیکی در اندروید 4.2 اضافه شد (قبلش تک کاربره و با UID بود)
- کاربران دارای دایرکتوری داده اختصاصی خود در/data/system/users/ هستند
- هر کاربر یک کپی از دایرکتوری داده برنامه را دریافت می کند
- برای تشخیص برنامه های نصب شده برای هر کاربر، اندروید یک UID موثر جدید را به هر برنامه اختصاص می دهد
- کاربری که برای اولین بار دستگاه را راه اندازی می کند، مالک دستگاه است و می تواند سایر کاربران را مدیریت کند
---
<!-- slide dir="rtl" -->
### SELinux

- مدل امنیتی سنتی اندروید به شدت به UID ها و GID های اعطا شده به برنامه ها متکی است. 
- هیچ چیز مانع از اعطای دسترسی جهانی یک برنامه به فایل هایش (چه عمدی و چه به دلیل خطای برنامه نویسی) نمی شود.
- هیچ چیز مانع از سوء استفاده برنامه های مخرب از بیت‌های دسترسی بیش از حد مجاز فایل‌های سیستم یا سوکت‌های محلی نمی شود

---

این آسیب پذیری ها در مدل کنترل دسترسی پیش فرض به کار گرفته شده توسط لینوکس، که به عنوان کنترل دسترسی اختیاری (DAC) شناخته می شود، اجتناب ناپذیر هستند.
- اختیاری بودن در اینجا به این معناست که هنگامی که یک کاربر به یک منبع خاص دسترسی پیدا می کند، می تواند آن را به صلاحدید خود به کاربر دیگری منتقل کند.
- از نسخه 4.4، SELinux تخلفات از پالیسی سیستم باعث ایجاد خطاهای زمان اجرا می شود.
